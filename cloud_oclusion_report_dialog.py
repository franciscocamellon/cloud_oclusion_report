# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CloudOclusionReportDialog
                                 A QGIS plugin
 Cloud Oclusion Report
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-06-12
        git sha              : $Format:%H$
        copyright            : (C) 2023 by CloudOclusionReport
        email                : CloudOclusionReport@email.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.core import QgsProject, QgsMapLayerProxyModel
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QDateTime

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'cloud_oclusion_report_dialog_base.ui'))


class CloudOclusionReportDialog(QtWidgets.QDialog, FORM_CLASS):

    def __init__(self, parent=None):
        """Constructor."""
        super(CloudOclusionReportDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.connect_layer_to_field_combo_box()
        self.report_date_de.setDateTime(QDateTime.currentDateTime())
        self.evaluate_end_date_de.setDateTime(QDateTime.currentDateTime())
        self.evaluation_layer_cb.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.evaluate_bt.clicked.connect(self.get_occlusion_result)
        self.report_bt.clicked.connect(self.get_input_data)
        self.evaluation_layer_cb.layerChanged.connect(self.connect_layer_to_field_combo_box)

    def get_data(self):
        teste = self.om_cb.currentText()
        print(teste)
        return teste

    def get_layer_name(self, layer):
        # for layer in QgsProject.instance().mapLayers().values():
        return layer.name()

    def connect_layer_to_field_combo_box(self):
        current_layer = self.evaluation_layer_cb.currentLayer()
        self.evaluation_field_cb.setLayer(current_layer)
        # fields_list = [field.name() for field in current_layer.fields()]
        # self.evaluation_field_cb.setFields(fields_list)

    def filter_by_occlusion(self):
        nonconforming = []
        conforming = []
        analysis_dict = {}

        edicao_layer = QgsProject.instance().mapLayersByName('edicao_area_sem_dados_a')[0]
        for feature in edicao_layer.getFeatures():
            texto_edicao = feature['texto_edicao']
            area_oclusao = feature['area_oclusao']
            if texto_edicao in analysis_dict:
                analysis_dict[texto_edicao].append(area_oclusao)
            else:
                analysis_dict[texto_edicao] = [area_oclusao]

        for key in analysis_dict:
            if max(analysis_dict[key]) >= 0.2:
                nonconforming.append(key)
            else:
                conforming.append(key)

        return conforming, nonconforming

    def get_occlusion_result(self):
        conforming, nonconforming = self.filter_by_occlusion()
        block_text = self.block_cb.currentText()

        if block_text in nonconforming:
            analysis_answer = 'Foram identificadas nuvens ou oclusões com área maior ou igual a 0,2 km².'
            conformity = 'Não Conforme'
        else:
            analysis_answer = 'Não foram identificadas nuvens ou oclusões com área maior ou igual a 0,2 km².'
            conformity = 'Conforme'
        print(analysis_answer, conformity)
        return analysis_answer, conformity

    def get_input_data(self):
        analysis_answer, conformity = self.get_occlusion_result()

        input_data = [
            self.om_cb.currentText(),
            self.report_number_sp.text(),
            self.block_cb.currentText(),
            self.work_period_month_cb.currentText(),
            self.work_period_year_cb.currentText(),
            self.evaluate_end_date_de.text(),
            conformity,
            analysis_answer,
            '{} {}'.format(self.evaluator_grad_cb.currentText(), self.evaluator_name_le.text()),
            '{} {}'.format(self.manager_pst_cb.currentText(), self.manager_name_le.text()),
            self.report_date_de.text()
        ]

        print(input_data)
        return input_data

